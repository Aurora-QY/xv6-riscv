diff --git a/answers-pgtbl.txt b/answers-pgtbl.txt
new file mode 100644
index 0000000..969ef47
--- /dev/null
+++ b/answers-pgtbl.txt
@@ -0,0 +1,4 @@
+Page 0:包含内核代码和数据，这是内核的一部分，对用户进程是不可见的，因此用户进程无法访问它。这些区域通常具有只读和执行权限。
+Page 1:内核将此页用于映射与I/O设备（例如显卡、磁盘控制器等）通信的区域。这些区域可能需要在内核和用户空间之间共享，以便用户进程可以与硬件交互。用户进程具有对此页面的一些读写权限，允许它与设备进行通信。
+
+Page 2:用户进程的内核栈。内核栈用于处理中断、异常和系统调用。它通常具有读写权限，因为内核需要在栈上执行一些操作。
diff --git a/grade-lab-pgtbl b/grade-lab-pgtbl
index 2b0b49d..4e36aa6 100755
--- a/grade-lab-pgtbl
+++ b/grade-lab-pgtbl
@@ -62,7 +62,7 @@ def test_count():
 def test_usertests():
     r.run_qemu(shell_script([
         'usertests'
-    ]), timeout=300)
+    ]), timeout=3000)
 
 def usertest_check(testcase, nextcase, output):
     if not re.search(r'\ntest {}: [\s\S]*OK\ntest {}'.format(testcase, nextcase), output):
diff --git a/kernel/defs.h b/kernel/defs.h
index a73b4f7..95d1de3 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -13,6 +13,7 @@ struct mbuf;
 struct sock;
 #endif
 
+
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -109,6 +110,10 @@ int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
 
+void 		proc_freewalk(pagetable_t pagetable);
+pte_t * 	walk(pagetable_t pagetable, uint64 va, int alloc);
+
+
 // swtch.S
 void            swtch(struct context*, struct context*);
 
@@ -179,6 +184,15 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 
+void 		vmprint(pagetable_t pagetable);
+void 		ukvmmap(pagetable_t kpagetable, uint64 va, uint64 pa, uint64 sz, int perm);
+pagetable_t 	ukvminit(void);
+void 		ukvminithart(pagetable_t kpagetable);
+int 		pagecopy(pagetable_t oldpage, pagetable_t newpage, uint64 begin, uint64 end);
+
+int             copyin_new(pagetable_t, char *, uint64, uint64);
+int             copyinstr_new(pagetable_t, char *, uint64, uint64);
+
 // plic.c
 void            plicinit(void);
 void            plicinithart(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 0e8762f..78a6eab 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -63,7 +63,7 @@ exec(char *path, char **argv)
 
   p = myproc();
   uint64 oldsz = p->sz;
-
+  
   // Allocate two pages at the next page boundary.
   // Use the second as the user stack.
   sz = PGROUNDUP(sz);
@@ -115,6 +115,16 @@ exec(char *path, char **argv)
   p->trapframe->epc = elf.entry;  // initial program counter = main
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
+  
+  // 复制新的kernel page并刷新TLB
+  if (pagecopy(p->pagetable, p->kpagetable, 0, p->sz) != 0) {
+    goto bad;
+  }
+  // 因为load进来了新的program, 刷新一下内存映射
+  ukvminithart(p->kpagetable);
+
+  if (p->pid == 1)
+    vmprint(p->pagetable);
 
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
diff --git a/kernel/proc.c b/kernel/proc.c
index dab1e1d..de130f3 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -34,12 +34,7 @@ procinit(void)
       // Allocate a page for the process's kernel stack.
       // Map it high in memory, followed by an invalid
       // guard page.
-      char *pa = kalloc();
-      if(pa == 0)
-        panic("kalloc");
-      uint64 va = KSTACK((int) (p - proc));
-      kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
-      p->kstack = va;
+
   }
   kvminithart();
 }
@@ -121,6 +116,26 @@ found:
     return 0;
   }
 
+  // 初始化新增的内核映像页表
+  p->kpagetable = ukvminit();
+  if(p->kpagetable == 0) {
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // 将栈初始化部分从procinit移动到这里
+  // 分配一个页框作为内核堆栈，并将其映射到用户的内核页表中。
+  char *pa = kalloc();  // 分配一页内存作为内核堆栈的物理地址。
+  if (pa == 0)
+    panic("kalloc");    // 如果分配失败，触发panic，即终止程序执行。
+  // 计算用户内核栈的虚拟地址，并将物理地址pa映射到虚拟地址va。
+  uint64 va = KSTACK((int) (p - proc));  // 计算用户内核栈的虚拟地址。
+  ukvmmap(p->kpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);  // 将物理地址映射到虚拟地址。
+
+  // 将用户的内核栈虚拟地址保存在进程结构体中，以便后续使用。
+  p->kstack = va;
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
   memset(&p->context, 0, sizeof(p->context));
@@ -130,6 +145,20 @@ found:
   return p;
 }
 
+void proc_freewalk(pagetable_t pagetable) {
+  for (int i = 0; i < PTE_IN_PGTBL; i++) {
+    pte_t pte = pagetable[i];
+    if (pte & PTE_V) {
+      pagetable[i] = 0;
+      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+        uint64 child = PTE2PA(pte);
+        proc_freewalk((pagetable_t)child);
+      }
+    }
+  }
+  kfree((void*)pagetable);
+}
+
 // free a proc structure and the data hanging from it,
 // including user pages.
 // p->lock must be held.
@@ -142,6 +171,20 @@ freeproc(struct proc *p)
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
+  //释放内核栈
+  if(p->kstack) {
+    pte_t* pte = walk(p->kpagetable, p->kstack, 0);
+    if(pte == 0)
+      panic("freeproc: walk");
+    kfree((void*)PTE2PA(*pte));
+  }
+  p->kstack = 0;
+  // 释放内核映射页表
+  if(p->kpagetable) {
+    proc_freewalk(p->kpagetable);
+  }
+  p->kpagetable = 0;
+  
   p->sz = 0;
   p->pid = 0;
   p->parent = 0;
@@ -220,7 +263,9 @@ userinit(void)
   // and data into it.
   uvminit(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
-
+  
+  pagecopy(p->pagetable, p->kpagetable, 0, p->sz);
+  
   // prepare for the very first "return" from kernel to user.
   p->trapframe->epc = 0;      // user program counter
   p->trapframe->sp = PGSIZE;  // user stack pointer
@@ -236,21 +281,38 @@ userinit(void)
 // Grow or shrink user memory by n bytes.
 // Return 0 on success, -1 on failure.
 int
-growproc(int n)
-{
-  uint sz;
-  struct proc *p = myproc();
+growproc(int n) {
+  uint sz;                 // 新的虚拟地址空间大小
+  struct proc *p = myproc(); // 获取当前进程结构体指针
+
+  sz = p->sz; // 获取当前进程的虚地址空间大小
 
-  sz = p->sz;
-  if(n > 0){
-    if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
+  if (n > 0) { // 如果n为正，表示增加虚拟地址空间
+    // 检查新的虚拟地址空间是否超出限制，然后尝试在页表中为新的地址范围分配内存
+    if (sz + n > PLIC || (sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
+      return -1; // 分配失败时返回-1
+    }
+    // 将旧地址范围的页面复制到新地址范围，建立新页表中的映射
+    if (pagecopy(p->pagetable, p->kpagetable, p->sz, sz) != 0) {
+      // 如果页面复制失败，在增量同步失败时返回-1
       return -1;
     }
-  } else if(n < 0){
+  } else if (n < 0) { // 如果n为负，表示减少虚拟地址空间
+    // 释放指定范围的虚拟地址空间，获取新的虚拟地址空间大小
     sz = uvmdealloc(p->pagetable, sz, sz + n);
+    if (sz != p->sz) {
+      // 取消内核页表中的映射，进行缩量同步
+      uvmunmap(p->kpagetable, PGROUNDUP(sz), (PGROUNDUP(p->sz) - PGROUNDUP(sz)) / PGSIZE, 0);
+    }
   }
+
+  // 初始化硬件寄存器，将新的内核页表地址加载到satp寄存器
+  ukvminithart(p->kpagetable);
+
+  // 更新进程的虚拟地址空间大小
   p->sz = sz;
-  return 0;
+  
+  return 0; // 成功时返回0
 }
 
 // Create a new process, copying the parent.
@@ -275,6 +337,12 @@ fork(void)
   }
   np->sz = p->sz;
 
+  if (pagecopy(np->pagetable, np->kpagetable, 0, np->sz) != 0) {
+    freeproc(np);
+    release(&np->lock);
+    return -1;
+  }
+
   np->parent = p;
 
   // copy saved user registers.
@@ -473,8 +541,13 @@ scheduler(void)
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+        
+	ukvminithart(p->kpagetable);
+        
         swtch(&c->context, &p->context);
 
+	kvminithart();
+
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..14441d6 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  
+  pagetable_t kpagetable;
 };
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 0aec003..7459319 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -323,6 +323,8 @@ sfence_vma()
 #define PGSIZE 4096 // bytes per page
 #define PGSHIFT 12  // bits of offset within a page
 
+#define PTE_IN_PGTBL (PGSIZE / sizeof(pte_t)) // 每个页表包含的页表项数量,值为4096 / 8 = 512
+
 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
 
diff --git a/kernel/vm.c b/kernel/vm.c
index bccb405..290adb7 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -6,6 +6,11 @@
 #include "defs.h"
 #include "fs.h"
 
+#include "spinlock.h"
+#include "proc.h"
+
+//#include "vmcopyin.c"
+
 /*
  * the kernel's page table.
  */
@@ -15,6 +20,138 @@ extern char etext[];  // kernel.ld sets this to end of kernel code.
 
 extern char trampoline[]; // trampoline.S
 
+// 递归地打印页表的内容
+void vmprint_recursive(pagetable_t pagetable, int level) {
+  // 遍历页表中的所有条目
+  for (int i = 0; i < PTE_IN_PGTBL; ++i) {
+  //for (int i = 0; i < 1024; ++i) {
+    pte_t pte = pagetable[i];
+    // 检查当前 PTE 是否有效
+    if (pte & PTE_V) {
+      uint64 pa = PTE2PA(pte);// 获取物理地址
+      for (int j = 0; j < level; ++j) {// 打印缩进
+        if (j)
+          printf(" ");
+        printf("..");
+      }
+      // 打印 PTE 编号、PTE 值和对应的物理地址
+      printf("%d: pte %p pa %p\n", i, pte, pa);
+      // 如果 PTE 没有读、写、执行权限，表示它指向另一个页表页
+      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)
+        vmprint_recursive((pagetable_t)pa, level+1);// 递归打印下一级的页表
+    }
+  }
+}
+
+void vmprint(pagetable_t pagetable) {
+  printf("page table %p\n", pagetable);
+  vmprint_recursive(pagetable, 1);
+} 
+
+
+// 该函数用于将虚拟地址范围映射到物理地址，并设置对应的权限。
+void ukvmmap(pagetable_t kpagetable, uint64 va, uint64 pa, uint64 sz, int perm) {
+  // 调用mappages函数来将虚拟地址范围映射到物理地址范围，并设置权限。
+  // 如果映射失败，触发panic，即终止程序执行。
+  if(mappages(kpagetable, va, sz, pa, perm) != 0)
+    panic("ukvmmap");
+}
+
+// 该函数用于初始化一个页表，并进行一些初始化映射。
+pagetable_t ukvminit() {
+  // 为内核页表分配一页内存（PGSIZE字节大小），并将其清零。
+  pagetable_t kpagetable = (pagetable_t) kalloc();
+  memset(kpagetable, 0, PGSIZE);
+
+  // 将一些关键的硬件设备、内核代码和数据区域进行映射。
+
+  // 映射UART0设备的物理地址到相应的虚拟地址，并设置读写权限。
+  ukvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+
+  // 映射VIRTIO0设备的物理地址到相应的虚拟地址，并设置读写权限。
+  ukvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+
+  // 映射CLINT设备的物理地址到相应的虚拟地址，并设置读写权限。
+  ukvmmap(kpagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
+
+  // 映射PLIC设备的物理地址到相应的虚拟地址，并设置读写权限。
+  ukvmmap(kpagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+
+  // 映射内核代码和只读数据区域的物理地址到相应的虚拟地址，并设置读执行权限。
+  ukvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+
+  // 映射从只读数据区域末尾到物理内存的结束地址，用于内核数据，设置读写权限。
+  ukvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+
+  // 映射trampoline代码的物理地址到相应的虚拟地址，并设置读执行权限。
+  ukvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+
+  // 返回初始化后的内核页表。
+  return kpagetable;
+}
+
+// 该函数用于在Hart（硬件线程）启动时初始化页表，以便让该Hart能够使用正确的虚拟地址映射。
+void ukvminithart(pagetable_t kpagetable)
+{
+  // 调用w_satp函数，将传入的内核页表kpagetable的信息设置到SATP寄存器中。
+  // SATP寄存器是RISC-V体系结构中的一个寄存器，用于指定页表的位置和格式。
+  w_satp(MAKE_SATP(kpagetable));
+
+  // 调用sfence_vma函数，执行虚拟内存地址的同步操作。
+  // sfence_vma指令用于确保之前的虚拟内存操作对所有Hart都是可见的，以避免不一致性。
+  sfence_vma();
+}
+
+// 和mappages一模一样, 只不过不再panic remapping, 直接强制复写
+int umappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) {
+  uint64 a, last;
+  pte_t *pte;
+
+  a = PGROUNDDOWN(va);
+  last = PGROUNDDOWN(va + size - 1);
+  for(;;){
+    if((pte = walk(pagetable, a, 1)) == 0)
+      return -1;
+    *pte = PA2PTE(pa) | perm | PTE_V;
+    if(a == last)
+      break;
+    a += PGSIZE;
+    pa += PGSIZE;
+  }
+  return 0;
+}
+
+// 函数目的：将给定的旧页表中指定范围的页复制到新页表中。
+int pagecopy(pagetable_t oldpage, pagetable_t newpage, uint64 begin, uint64 end) {
+  pte_t *pte;         // 页表项指针
+  uint64 pa, i;       // 物理地址，循环变量
+  uint flags;         // 标志位
+  begin = PGROUNDUP(begin); // 向上对齐begin到页边界
+
+  // 遍历从begin到end范围内的虚拟地址，每次递增一个页的大小
+  for (i = begin; i < end; i += PGSIZE) {
+    // 使用walk函数，在旧页表中查找虚拟地址i对应的页表项
+    if ((pte = walk(oldpage, i, 0)) == 0)
+      panic("pagecopy walk oldpage nullptr"); // 如果找不到，触发panic，终止程序执行
+    // 检查页表项是否有效（Valid标志位被设置）
+    if ((*pte & PTE_V) == 0)
+      panic("pagecopy oldpage pte not valid"); // 如果无效，触发panic，终止程序执行
+    pa = PTE2PA(*pte); // 从页表项获取物理地址
+    flags = PTE_FLAGS(*pte) & (~PTE_U); // 获取标志位并将用户标志（U flag）抹去
+
+    // 使用umappages函数，在新页表中映射虚拟地址i到物理地址pa，使用标志位flags
+    if (umappages(newpage, i, PGSIZE, pa, flags) != 0) {
+      goto err; // 如果映射失败，跳转到err标签处理
+    }
+  }
+  return 0; // 成功时返回0
+
+err:
+  // 在发生错误的情况下，取消刚刚建立的映射，并返回-1
+  uvmunmap(newpage, 0, i / PGSIZE, 1);
+  return -1;
+}
+
 /*
  * create a direct-map page table for the kernel.
  */
@@ -132,7 +269,7 @@ kvmpa(uint64 va)
   pte_t *pte;
   uint64 pa;
   
-  pte = walk(kernel_pagetable, va, 0);
+  pte = walk(myproc()->kpagetable, va, 0);
   if(pte == 0)
     panic("kvmpa");
   if((*pte & PTE_V) == 0)
@@ -379,23 +516,25 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 int
 copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
-  uint64 n, va0, pa0;
-
-  while(len > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > len)
-      n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
-
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
+  return copyin_new(pagetable, dst, srcva, len);
+  
+//  uint64 n, va0, pa0;
+//
+//  while(len > 0){
+//    va0 = PGROUNDDOWN(srcva);
+//    pa0 = walkaddr(pagetable, va0);
+//    if(pa0 == 0)
+//      return -1;
+//    n = PGSIZE - (srcva - va0);
+//    if(n > len)
+//      n = len;
+//    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+//
+//    len -= n;
+//    dst += n;
+//    srcva = va0 + PGSIZE;
+//  }
+//  return 0;
 }
 
 // Copy a null-terminated string from user to kernel.
@@ -405,38 +544,41 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 int
 copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 {
-  uint64 n, va0, pa0;
-  int got_null = 0;
-
-  while(got_null == 0 && max > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > max)
-      n = max;
-
-    char *p = (char *) (pa0 + (srcva - va0));
-    while(n > 0){
-      if(*p == '\0'){
-        *dst = '\0';
-        got_null = 1;
-        break;
-      } else {
-        *dst = *p;
-      }
-      --n;
-      --max;
-      p++;
-      dst++;
-    }
-
-    srcva = va0 + PGSIZE;
-  }
-  if(got_null){
-    return 0;
-  } else {
-    return -1;
-  }
+  return copyinstr_new(pagetable, dst, srcva, max);
+  
+  
+//  uint64 n, va0, pa0;
+//  int got_null = 0;
+//
+//  while(got_null == 0 && max > 0){
+//    va0 = PGROUNDDOWN(srcva);
+//    pa0 = walkaddr(pagetable, va0);
+//    if(pa0 == 0)
+//      return -1;
+//    n = PGSIZE - (srcva - va0);
+//    if(n > max)
+//      n = max;
+//
+//    char *p = (char *) (pa0 + (srcva - va0));
+//    while(n > 0){
+//      if(*p == '\0'){
+//        *dst = '\0';
+//        got_null = 1;
+//        break;
+//      } else {
+//        *dst = *p;
+//      }
+//      --n;
+//      --max;
+//      p++;
+//      dst++;
+//    }
+//
+//    srcva = va0 + PGSIZE;
+//  }
+//  if(got_null){
+//    return 0;
+//  } else {
+//    return -1;
+//  }
 }
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..3c03207
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+18
