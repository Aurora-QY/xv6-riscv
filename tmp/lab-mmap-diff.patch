diff --git a/Makefile b/Makefile
index d8509b1..31803d4 100644
--- a/Makefile
+++ b/Makefile
@@ -175,6 +175,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_mmaptest\
 
 
 
diff --git a/grade-lab-mmap b/grade-lab-mmap
index f1a67bb..441fb9f 100755
--- a/grade-lab-mmap
+++ b/grade-lab-mmap
@@ -47,7 +47,7 @@ def test_mmaptest_fork_test():
 def test_usertests():
     r.run_qemu(shell_script([
         'usertests'
-    ]), timeout=300)
+    ]), timeout=3000)
     r.match('^ALL TESTS PASSED$')
 
 @test(1, "time")
diff --git a/kernel/file.h b/kernel/file.h
index b076d1d..e276c4f 100644
--- a/kernel/file.h
+++ b/kernel/file.h
@@ -13,6 +13,8 @@ struct file {
 #define minor(dev)  ((dev) & 0xFFFF)
 #define	mkdev(m,n)  ((uint)((m)<<16| (n)))
 
+#define NDIRECT 12
+
 // in-memory copy of an inode
 struct inode {
   uint dev;           // Device number
diff --git a/kernel/proc.c b/kernel/proc.c
index ba1a9e3..062c799 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -6,6 +6,8 @@
 #include "proc.h"
 #include "defs.h"
 
+#include "fcntl.h"
+
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
@@ -301,6 +303,17 @@ fork(void)
   pid = np->pid;
 
   np->state = RUNNABLE;
+//
+  // 复制父进程的文件映射
+  for(int i = 0; i < VMASIZE; i++) {
+    if(p->vma[i].used) {
+      // 复制 VMA 数据到新进程
+      memmove(&(np->vma[i]), &(p->vma[i]), sizeof(p->vma[i]));
+      // 增加文件引用计数，以防止文件被关闭
+      filedup(p->vma[i].file);
+    }
+  }
+//
 
   release(&np->lock);
 
@@ -353,6 +366,21 @@ exit(int status)
     }
   }
 
+ // 清理当前进程的文件映射
+  for(int i = 0; i < VMASIZE; i++) {
+    if(p->vma[i].used) {
+      // 如果映射标志为 MAP_SHARED，则将内容写回文件
+      if(p->vma[i].flags & MAP_SHARED)
+        filewrite(p->vma[i].file, p->vma[i].addr, p->vma[i].length);
+      // 关闭文件
+      fileclose(p->vma[i].file);
+      // 解除虚拟内存映射并释放物理页
+      uvmunmap(p->pagetable, p->vma[i].addr, p->vma[i].length/PGSIZE, 1);
+      // 将 VMA 标记为未使用
+      p->vma[i].used = 0;
+    }
+  }
+
   begin_op();
   iput(p->cwd);
   end_op();
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..09a1b39 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -1,3 +1,5 @@
+#define VMASIZE 16 //根据实验手册定义VMA结构体,数组长度为16
+
 // Saved registers for kernel context switches.
 struct context {
   uint64 ra;
@@ -82,6 +84,20 @@ struct trapframe {
 
 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+
+//vma(Virtual Memory Area)结构体
+struct vma {
+  int used;
+  uint64 addr;	// 映射地址
+  int length;	// 映射长度
+  int prot;	// 权限
+  int flags;	// 标志
+  int fd;	// 文件描述符
+  int offset;	// 偏移量
+  int dirty;	// 是否修改过标志
+  struct file *file;
+};
+
 // Per-process state
 struct proc {
   struct spinlock lock;
@@ -103,4 +119,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  
+  struct vma vma[VMASIZE];
+  //在proc中加入文件系统的vma结构体数组
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..11334c1 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -105,6 +105,10 @@ extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
 
+extern uint64 sys_mmap(void);
+extern uint64 sys_munmap(void);
+
+
 static uint64 (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
@@ -127,6 +131,9 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+
+[SYS_mmap]    sys_mmap,
+[SYS_munmap]  sys_munmap,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..5e4d507 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+//mmap
+#define SYS_mmap   22
+#define SYS_munmap 23
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..88beca7 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -484,3 +484,110 @@ sys_pipe(void)
   }
   return 0;
 }
+
+//mmap
+uint64
+sys_mmap(void)
+{
+  uint64 addr;
+  int length, prot, flags, fd, offset;// 映射参数,目标虚拟地址,映射长度,权限标志,标志,文件描述副,起始偏移量
+  struct file *file;
+  struct proc *p = myproc();
+
+  // 检查从用户态获取传入的参数
+  if (argaddr(0, &addr) || argint(1, &length) || argint(2, &prot) ||
+      argint(3, &flags) || argfd(4, &fd, &file) || argint(5, &offset))
+    return -1; // 参数传递错误，返回 -1
+
+  // 检查文件的权限是否与映射的权限匹配
+  if (!file->writable && (prot & PROT_WRITE) && flags == MAP_SHARED)
+    return -1; // 权限不匹配，返回 -1
+
+  // 向上对齐长度
+  length = PGROUNDUP(length);
+
+  // 检查进程的地址空间是否足够
+  if (p->sz > MAXVA - length)
+    return -1; // 地址空间不足，返回 -1
+
+  // 遍历 VMA 数组，找到一个未使用的 VMA
+  for (int i = 0; i < VMASIZE; ++i) {
+    if (p->vma[i].used == 0) {
+      p->vma[i].used = 1; // 标记 VMA 插槽为已使用
+      p->vma[i].addr = p->sz; // 设置映射的虚拟地址
+      p->vma[i].length = length; // 设置映射的长度
+      p->vma[i].prot = prot; // 设置权限标志
+      p->vma[i].flags = flags; // 设置映射标志
+      p->vma[i].fd = fd; // 设置文件描述符
+      p->vma[i].file = file; // 设置映射的文件
+      p->vma[i].offset = offset; // 设置映射的起始偏移
+      
+      filedup(file); // 增加文件的引用计数，以保证文件在映射期间不会被关闭
+      p->sz += length; // 虚拟地增加进程大小，但没有实际分配物理页
+
+
+      return p->vma[i].addr; // 返回分配的虚拟地址
+    }
+  }
+
+  return -1; // 无可用的 VMA，返回 -1
+}
+
+uint64
+sys_munmap(void)
+{
+  uint64 addr;
+  int length;
+  struct proc *p = myproc();
+  struct vma *vma = 0;
+
+  // 解析参数
+  if(argaddr(0, &addr) || argint(1, &length))
+    return -1;
+
+  // 将虚拟地址和长度进行对齐
+  addr = PGROUNDDOWN(addr);
+  length = PGROUNDUP(length);
+
+  // 查找对应的 VMA
+  for(int i = 0; i < VMASIZE; i++) {
+    if (addr >= p->vma[i].addr || addr < p->vma[i].addr + p->vma[i].length) {
+      vma = &p->vma[i];
+      break;
+    }
+  }
+
+  // 如果找不到对应的 VMA，则返回
+  if(vma == 0)
+    return 0;
+
+  // 如果要取消映射的地址是 VMA 的起始地址
+  if(vma->addr == addr) {
+    // 更新 VMA 的地址和长度
+    vma->addr += length;
+    vma->length -= length;
+
+    // 如果是共享映射，将修改的内容写回文件
+    if(vma->flags & MAP_SHARED){
+      if (vma->dirty) {
+        // 页面被修改过，将区域的数据写回文件
+        if (filewrite(vma->file, addr, length) < 0)
+          printf("munmap: filewrite < 0\n");
+      vma->dirty = 0; // 写入文件后，重置 dirty 标志位为 0
+      }
+    }
+
+    // 取消映射并释放对应的物理内存
+    uvmunmap(p->pagetable, addr, length/PGSIZE, 1);
+
+    // 如果 VMA 长度变为 0，则关闭文件并标记为未使用
+    if(vma->length == 0) {
+      fileclose(vma->file);
+      vma->used = 0;
+    }
+  }
+
+  return 0;
+}
+
+
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..2b3dd14 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -6,6 +6,14 @@
 #include "proc.h"
 #include "defs.h"
 
+//新增头文件(file结构体定义与权限相关宏定义)
+#include "fcntl.h"
+#include "fs.h"
+#include "sleeplock.h"
+#include "file.h"
+
+struct sleeplock;
+
 struct spinlock tickslock;
 uint ticks;
 
@@ -67,7 +75,54 @@ usertrap(void)
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
-  } else {
+  } else if (r_scause() == 13 || r_scause() == 15) {
+    // 由于是懒加载,所以读写虚拟地址时会存在缺页中断,需要将物理地址上的数据读入到虚拟地址(实际分配)
+    uint64 va = r_stval(); // 获取造成缺页中断的虚拟地址
+
+    // 检查虚拟地址的合法性
+    if (va >= p->sz || va > MAXVA || PGROUNDUP(va) == PGROUNDDOWN(p->trapframe->sp))
+      p->killed = 1;
+    else {
+      struct vma *vma = 0;
+
+      // 在进程的 VMA 数组中查找匹配的 VMA
+      for (int i = 0; i < VMASIZE; i++) {
+        if (p->vma[i].used == 1 && va >= p->vma[i].addr && va < p->vma[i].addr + p->vma[i].length) {
+          vma = &p->vma[i];
+          break;
+        }
+      }
+
+      if (vma) {
+        va = PGROUNDDOWN(va); // 对虚拟地址进行对齐
+        uint64 offset = va - vma->addr; // 计算在文件中的偏移量
+        uint64 mem = (uint64)kalloc(); // 分配一个物理页
+
+        if (mem == 0) {
+          // 分配物理页失败，将进程标记为被终止
+          p->killed = 1;
+        } else {
+          memset((void*)mem, 0, PGSIZE); // 清空物理页内容
+          ilock(vma->file->ip); // 获取文件的锁
+          readi(vma->file->ip, 0, mem, offset, PGSIZE); // 从文件中读取内容到物理页
+          iunlock(vma->file->ip); // 释放文件的锁
+
+          int PTEflag = PTE_U; // 设置页表项的标志
+          if (vma->prot & PROT_READ) PTEflag |= PTE_R;
+          if (vma->prot & PROT_WRITE) PTEflag |= PTE_W;
+          if (vma->prot & PROT_EXEC) PTEflag |= PTE_X;
+
+          // 将物理页映射到虚拟地址，并设置页表项的标志
+          if (mappages(p->pagetable, va, PGSIZE, mem, PTEflag) != 0) {
+            kfree((void*)mem); // 映射失败，释放物理页
+            p->killed = 1; // 标记进程为被终止状态
+          }
+          vma->dirty = 1; // 页面被修改，设置 dirty 标志位为 1
+        }
+      }
+    }
+  }
+    else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
     p->killed = 1;
diff --git a/kernel/vm.c b/kernel/vm.c
index b47f111..9245a5a 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -172,7 +172,9 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
     if((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
     if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
+      continue;
+      //panic("uvmunmap: not mapped");
+      //在执行虚拟内存映射的解除操作时，如果当前页表项的 PTE_V（有效位）为 0，表示该虚拟地址没有进行有效映射，直接跳过处理即可。这可以避免处理不必要的操作。
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
     if(do_free){
@@ -306,7 +308,9 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+      continue;
+      //panic("uvmcopy: page not present");
+      //在执行虚拟内存映射的解除操作时，如果当前页表项的 PTE_V（有效位）为 0，表示该虚拟地址没有进行有效映射，直接跳过处理即可。这可以避免处理不必要的操作。
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..f599e28
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+10
diff --git a/user/user.h b/user/user.h
index b71ecda..295a8f2 100644
--- a/user/user.h
+++ b/user/user.h
@@ -40,3 +40,7 @@ void free(void*);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+
+// mmap
+void* mmap(void *addr, int length, int prot, int flags, int fd, uint offset);
+int munmap(void *addr, int length);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..a15ddc7 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+
+
+entry("mmap");
+entry("munmap");
