1)	哪些寄存器包含函数的参数？例如，在 main 调用 printf 时，哪个寄存器保存了 13？
答：a0,a1,a2包含了参数的参数。a2保存了13。
根据main中这一条汇编信息可以看出，13被放到了a2寄存器中
  24:	4635                	li	a2,13
2)	在 main 的汇编代码中，函数 f 的调用在哪里？函数 g 的调用在哪里？（提示：编译器可能会内联函数。）
答：函数f在main的汇编代码中没有实际的函数调用，printf("%d %d\n", f(8)+1, 13);中的f(8)实际上不会跳转到f计算并返回，而是直接展开，因为编译器将其内联到了main函数中。
函数g则先内联到f中，再进一步内联到main中。
3)	函数 printf 的地址在哪里？
答：0x0000000000000628
在call.asm中可见：
0000000000000628 <printf>:

void
printf(const char *fmt, ...)
{
 628:	711d                	addi	sp,sp,-96
......
4)	在 main 中的 jalr 到 printf 之后，寄存器 ra 中有什么值？
答：0x38(ra=pc+4)
jalr指令将pc+4赋给当前寄存器，即下一条指令的地址。
5)	运行以下代码。
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
输出是什么？ 如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？
答：He110 World 。0x726c6400。不需要
%s输出字符串的起始地址为i，按照字符的格式读取字符，直到读取到 '\0' 为止。如果按照题目中的i的值，若是大端序表示，则读取顺序为72->6c->64->00；若是小端序表示，则读取顺序为00->64->6c->72。所以若是内存中存放的数是：72 6c 64 00，则小端序表示刚好对应rld+'\0'。
57616的16进制表示就是e110，与大小端序无关。
6)	在以下代码中，'y=' 后会打印什么？（注意：答案不是特定的值。）为什么会发生这种情况？
printf("x=%d y=%d", 3);
答：a2寄存器中的值（随机）
printf的format字符串在寄存器a0（不是只有一个3作为参数）, 3在寄存器a1。所以y只能打印a2中留存的值。

